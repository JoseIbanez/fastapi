from typing import Optional

from enum import Enum
from fastapi import FastAPI, Body, HTTPException, status
from pydantic import BaseModel, Field
import time
import producer
import json

from apiClasses import AZ, Datacenter, TShirtSize, OperatingSystem, VMRequest, VMInstance
from apiClasses import Item, GenericTask
from config import getVersion, getConfig

deployments = []
app = FastAPI(
    title = "CI3.0 Project",
    description = "Private cloud CI 3.0, autogenerated documentation",
    version = "0.0.1"

)


@app.get("/")
def read_root():
    version = getVersion()
    return {"Hello": "World", "version":version}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Optional[str] = None):
    return {"item_id": item_id, "q": q}


@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    return {"item_name": item.name, "item_id": item_id}


@app.post("/deployments/vm/",
    response_model=VMInstance,
    summary="Deploy a new VM",
    status_code=status.HTTP_201_CREATED
    )
def create_vm(request: VMRequest):
    """
    Create a VM deployment
    """
    id = len(deployments)

    item = VMInstance(id=id)
    item.vmname = "vg1111yr"
    item.az = request.az
    item.dc = request.dc
    item.rd = request.rd
    item.size = request.size
    item.os = request.os
    print(item.dict())

    deployments.append(item.dict())
    return item

@app.get("/deployments/vm/{id}",
    response_model=VMInstance
    )
def get_vm(id: int):
    """
    Get a VM deployment
    """
    item=deployments[id]
    return item

@app.post("/task/")
def exe_genericTask(task: GenericTask):
    """
    Execute generic task
    """

    p1 = producer.MyProducter()


    item = task.dict()
    name = item.get("name")
    delay = item.get("delay")
    result = item.get("result")

    p1.publish(f"{name} running")
 
    print(f"delay: {delay}")
    time.sleep(delay)
 
    if result in ['error', 'fail']:
        p1.publish(f"{name} failed")
        raise HTTPException(status_code=503, detail=f"{name} error:{result}")
 
    p1.publish(f"{name} done")
    #p1.disconnect()
 
    return { name: result, "state": "done" }